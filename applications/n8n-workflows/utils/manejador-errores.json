{
  "name": "Utils - Error Handler Utility",
  "description": "Workflow utilitario enfocado en manejo centralizado de errores y validaciones. Principio SRP: Una sola responsabilidad - manejo estandarizado de errores.",
  "tags": ["utils", "error", "validation", "srp", "centralized"],
  "nodes": [
    {
      "parameters": {
        "workflowId": "{{ $json.workflowId }}"
      },
      "id": "workflow-trigger",
      "name": "Trigger del Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en categorizar y procesar errores\n// Principio SRP: Una sola responsabilidad - clasificar tipo de error\n\nconst errorData = $input.first().json;\n\n// Validar que se recibieron datos de error\nif (!errorData.error_info && !errorData.error_message && !errorData.exception) {\n  throw new Error('No se proporcionaron datos de error para procesar');\n}\n\n// Extraer información del error\nconst errorMessage = errorData.error_message || errorData.exception?.message || 'Error no especificado';\nconst errorType = errorData.error_type || 'unknown';\nconst errorContext = errorData.context || {};\nconst tenantId = errorData.tenant_id || null;\nconst workflowName = errorData.workflow_name || 'workflow_desconocido';\nconst nodeId = errorData.node_id || 'nodo_desconocido';\n\n// Categorizar error según patterns comunes\nlet errorCategory = 'general';\nlet severity = 'medium';\nlet retryable = false;\nlet userFriendlyMessage = 'Ha ocurrido un error inesperado';\nlet technicalActions = [];\n\n// Análisis de categorías de error\nif (errorMessage.includes('UUID') || errorMessage.includes('tenant_id')) {\n  errorCategory = 'validation';\n  severity = 'high';\n  retryable = false;\n  userFriendlyMessage = 'Error de configuración del concesionario';\n  technicalActions = ['Verificar tenant_id', 'Validar configuración de concesionario'];\n}\nelse if (errorMessage.includes('Campo requerido') || errorMessage.includes('required')) {\n  errorCategory = 'validation';\n  severity = 'medium';\n  retryable = false;\n  userFriendlyMessage = 'Faltan datos requeridos para procesar la solicitud';\n  technicalActions = ['Verificar datos de entrada', 'Validar campos obligatorios'];\n}\nelse if (errorMessage.includes('timeout') || errorMessage.includes('network') || errorMessage.includes('connection')) {\n  errorCategory = 'network';\n  severity = 'medium';\n  retryable = true;\n  userFriendlyMessage = 'Error de conectividad temporalmente';\n  technicalActions = ['Reintentar operación', 'Verificar conectividad de red'];\n}\nelse if (errorMessage.includes('API') || errorMessage.includes('rate limit') || errorMessage.includes('quota')) {\n  errorCategory = 'api_limits';\n  severity = 'medium';\n  retryable = true;\n  userFriendlyMessage = 'Servicio temporalmente no disponible';\n  technicalActions = ['Esperar antes de reintentar', 'Verificar cuotas de API'];\n}\nelse if (errorMessage.includes('database') || errorMessage.includes('query') || errorMessage.includes('SQL')) {\n  errorCategory = 'database';\n  severity = 'high';\n  retryable = true;\n  userFriendlyMessage = 'Error interno del sistema';\n  technicalActions = ['Verificar conexión DB', 'Revisar queries SQL', 'Escalar a DevOps'];\n}\nelse if (errorMessage.includes('IA') || errorMessage.includes('AI') || errorMessage.includes('embedding') || errorMessage.includes('Gemini')) {\n  errorCategory = 'ai_processing';\n  severity = 'medium';\n  retryable = true;\n  userFriendlyMessage = 'Error en procesamiento inteligente';\n  technicalActions = ['Verificar configuración IA', 'Usar modo fallback', 'Reintentar con configuración reducida'];\n}\nelse if (errorMessage.includes('email') || errorMessage.includes('notification') || errorMessage.includes('SMTP')) {\n  errorCategory = 'notification';\n  severity = 'low';\n  retryable = true;\n  userFriendlyMessage = 'Error enviando notificaciones';\n  technicalActions = ['Verificar configuración SMTP', 'Validar destinatarios', 'Usar canal alternativo'];\n}\n\n// Generar ID único para tracking\nconst errorId = `ERR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n// Estructura estandarizada del error\nconst processedError = {\n  // Identificación\n  error_id: errorId,\n  error_category: errorCategory,\n  severity: severity,\n  retryable: retryable,\n  \n  // Contexto del error\n  context: {\n    tenant_id: tenantId,\n    workflow_name: workflowName,\n    node_id: nodeId,\n    timestamp: new Date().toISOString(),\n    user_agent: errorContext.user_agent || null,\n    request_id: errorContext.request_id || null\n  },\n  \n  // Detalles técnicos\n  technical_details: {\n    original_message: errorMessage,\n    error_type: errorType,\n    stack_trace: errorData.stack_trace || null,\n    additional_context: errorContext\n  },\n  \n  // Mensajes para usuarios\n  user_messaging: {\n    friendly_message: userFriendlyMessage,\n    show_retry_button: retryable,\n    estimated_resolution_time: retryable ? '5 minutos' : 'Contactar soporte'\n  },\n  \n  // Acciones técnicas recomendadas\n  technical_actions: technicalActions,\n  \n  // Configuración de notificaciones\n  notification_config: {\n    notify_user: true,\n    notify_tech_team: severity === 'high',\n    escalate_immediately: severity === 'critical',\n    log_to_monitoring: true\n  }\n};\n\nconsole.log('Error procesado y categorizado:', {\n  errorId: processedError.error_id,\n  category: processedError.error_category,\n  severity: processedError.severity,\n  retryable: processedError.retryable,\n  tenantId: tenantId\n});\n\nreturn [{ json: processedError }];"
      },
      "id": "categorize-error",
      "name": "Categorizar Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.severity }}",
              "operation": "equal",
              "value2": "high"
            }
          ]
        }
      },
      "id": "check-high-severity",
      "name": "¿Severidad Alta?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "error_logs",
        "columns": "error_id, tenant_id, workflow_name, node_id, error_category, severity, error_message, context_data, technical_actions, created_at",
        "additionalFields": {
          "values": "={{ [$json.error_id, $json.context.tenant_id, $json.context.workflow_name, $json.context.node_id, $json.error_category, $json.severity, $json.technical_details.original_message, JSON.stringify($json.context), JSON.stringify($json.technical_actions), $json.context.timestamp] }}"
        }
      },
      "id": "log-error-database",
      "name": "Registrar Error en BD",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "operation": "create",
        "resource": "execution",
        "workflowId": "notification-urgent-alert",
        "data": "={{ JSON.stringify({alert_type: 'high_severity_error', error_data: $json, immediate_escalation: true}) }}"
      },
      "id": "trigger-urgent-notification",
      "name": "Disparar Alerta Urgente",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en generar estrategia de recovery\n// Principio SRP: Una sola responsabilidad - determinar acciones de recuperación\n\nconst errorData = $input.first().json;\nconst logResult = $('Registrar Error en BD').item.json;\n\n// Determinar estrategia de recovery basada en categoría\nlet recoveryStrategy = {\n  can_auto_recover: false,\n  recovery_actions: [],\n  fallback_workflows: [],\n  user_instructions: errorData.user_messaging.friendly_message\n};\n\nswitch (errorData.error_category) {\n  case 'network':\n    recoveryStrategy = {\n      can_auto_recover: true,\n      recovery_actions: [\n        'Reintentar en 30 segundos',\n        'Usar conexión backup si está disponible',\n        'Reducir timeout de requests'\n      ],\n      fallback_workflows: ['network-recovery-handler'],\n      retry_delay: 30000, // 30 segundos\n      max_retries: 3\n    };\n    break;\n    \n  case 'api_limits':\n    recoveryStrategy = {\n      can_auto_recover: true,\n      recovery_actions: [\n        'Esperar hasta el reset del rate limit',\n        'Usar API key alternativa si está disponible',\n        'Implementar backoff exponencial'\n      ],\n      fallback_workflows: ['api-quota-manager'],\n      retry_delay: 60000, // 1 minuto\n      max_retries: 5\n    };\n    break;\n    \n  case 'ai_processing':\n    recoveryStrategy = {\n      can_auto_recover: true,\n      recovery_actions: [\n        'Usar configuración IA más conservadora',\n        'Reducir tamaño de prompt',\n        'Activar modo fallback con reglas predefinidas'\n      ],\n      fallback_workflows: ['ai-fallback-processor'],\n      retry_delay: 10000, // 10 segundos\n      max_retries: 2\n    };\n    break;\n    \n  case 'validation':\n    recoveryStrategy = {\n      can_auto_recover: false,\n      recovery_actions: [\n        'Solicitar datos corregidos al usuario',\n        'Usar valores por defecto cuando sea posible',\n        'Mostrar formulario de corrección'\n      ],\n      fallback_workflows: ['data-correction-form'],\n      user_action_required: true\n    };\n    break;\n    \n  case 'database':\n    recoveryStrategy = {\n      can_auto_recover: true,\n      recovery_actions: [\n        'Reintentar con conexión a BD secundaria',\n        'Usar caché temporal si está disponible',\n        'Escalar a equipo técnico si persiste'\n      ],\n      fallback_workflows: ['database-recovery-handler'],\n      retry_delay: 5000, // 5 segundos\n      max_retries: 3,\n      escalate_after_retries: true\n    };\n    break;\n    \n  default:\n    recoveryStrategy = {\n      can_auto_recover: false,\n      recovery_actions: [\n        'Registrar error para análisis manual',\n        'Notificar a equipo técnico',\n        'Ofrecer contacto con soporte'\n      ],\n      fallback_workflows: ['manual-error-analysis'],\n      requires_manual_intervention: true\n    };\n}\n\n// Enriquecer con datos del log\nconst recoveryPlan = {\n  error_reference: {\n    error_id: errorData.error_id,\n    log_id: logResult[0]?.id || null,\n    category: errorData.error_category,\n    severity: errorData.severity\n  },\n  \n  recovery_strategy: recoveryStrategy,\n  \n  monitoring: {\n    track_recovery_attempts: true,\n    success_metrics: ['recovery_time', 'user_satisfaction'],\n    failure_escalation: errorData.notification_config.escalate_immediately\n  },\n  \n  user_experience: {\n    show_progress_indicator: recoveryStrategy.can_auto_recover,\n    provide_alternatives: !recoveryStrategy.can_auto_recover,\n    estimated_resolution: recoveryStrategy.retry_delay ? \n      `${Math.ceil(recoveryStrategy.retry_delay / 1000)} segundos` : \n      'Tiempo variable'\n  },\n  \n  technical_context: {\n    original_error: errorData.technical_details,\n    recovery_initiated_at: new Date().toISOString(),\n    recovery_coordinator: 'error-handler-utility'\n  }\n};\n\nconsole.log('Plan de recuperación generado:', {\n  errorId: recoveryPlan.error_reference.error_id,\n  canAutoRecover: recoveryPlan.recovery_strategy.can_auto_recover,\n  recoveryActions: recoveryPlan.recovery_strategy.recovery_actions.length,\n  fallbackWorkflows: recoveryPlan.recovery_strategy.fallback_workflows.length\n});\n\nreturn [{ json: recoveryPlan }];"
      },
      "id": "generate-recovery-plan",
      "name": "Generar Plan Recuperación",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.recovery_strategy.can_auto_recover }}",
              "operation": "equal",
              "value2": true
            }
          ]
        }
      },
      "id": "check-auto-recoverable",
      "name": "¿Recuperación Automática?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1340, 400]
    },
    {
      "parameters": {
        "operation": "create",
        "resource": "execution",
        "workflowId": "{{ $json.recovery_strategy.fallback_workflows[0] || 'error-manual-handler' }}",
        "data": "={{ JSON.stringify($json) }}"
      },
      "id": "trigger-auto-recovery",
      "name": "Iniciar Recuperación Automática",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en manejar errores que requieren intervención manual\n// Principio SRP: Una sola responsabilidad - preparar escalación manual\n\nconst recoveryPlan = $input.first().json;\nconst errorData = recoveryPlan.error_reference;\n\n// Preparar datos para escalación manual\nconst manualEscalation = {\n  // Identificación del incidente\n  incident_id: `INC-${errorData.error_id}`,\n  error_reference: errorData,\n  \n  // Contexto para el equipo técnico\n  escalation_details: {\n    reason: 'Error no recuperable automáticamente',\n    severity: errorData.severity,\n    category: errorData.category,\n    requires_immediate_attention: errorData.severity === 'high',\n    \n    // Información de contexto\n    affected_tenant: recoveryPlan.technical_context.original_error.additional_context?.tenant_id,\n    workflow_affected: recoveryPlan.technical_context.original_error.additional_context?.workflow_name,\n    \n    // Acciones ya intentadas\n    previous_actions: 'Error categorizado y registrado en BD',\n    suggested_next_steps: recoveryPlan.recovery_strategy.recovery_actions\n  },\n  \n  // Configuración de notificaciones\n  notification_targets: {\n    primary_oncall: true,\n    tech_lead: errorData.severity === 'high',\n    product_team: false,\n    customer_success: recoveryPlan.recovery_strategy.user_action_required || false\n  },\n  \n  // SLA y expectativas\n  sla_requirements: {\n    initial_response: errorData.severity === 'high' ? '15 minutos' : '1 hora',\n    resolution_target: errorData.severity === 'high' ? '2 horas' : '24 horas',\n    customer_communication: recoveryPlan.recovery_strategy.user_action_required\n  },\n  \n  // Información del usuario afectado\n  user_impact: {\n    user_facing_message: recoveryPlan.user_experience.provide_alternatives,\n    blocking_user_workflow: !recoveryPlan.recovery_strategy.can_auto_recover,\n    alternative_solutions_available: recoveryPlan.recovery_strategy.fallback_workflows.length > 0\n  },\n  \n  // Metadatos de escalación\n  escalation_metadata: {\n    escalated_at: new Date().toISOString(),\n    escalation_source: 'error-handler-utility',\n    log_references: [recoveryPlan.error_reference.log_id],\n    monitoring_dashboard_links: [\n      `/monitoring/errors/${errorData.error_id}`,\n      `/monitoring/tenant/${recoveryPlan.technical_context.original_error.additional_context?.tenant_id}`\n    ]\n  }\n};\n\nconsole.log('Escalación manual preparada:', {\n  incidentId: manualEscalation.incident_id,\n  errorId: errorData.error_id,\n  severity: errorData.severity,\n  requiresImmediateAttention: manualEscalation.escalation_details.requires_immediate_attention\n});\n\nreturn [{ json: manualEscalation }];"
      },
      "id": "prepare-manual-escalation",
      "name": "Preparar Escalación Manual",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1560, 500]
    },
    {
      "parameters": {
        "operation": "create",
        "resource": "execution",
        "workflowId": "notification-incident-alert",
        "data": "={{ JSON.stringify($json) }}"
      },
      "id": "trigger-incident-notification",
      "name": "Notificar Incidente",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [1780, 500]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en generar respuesta final del manejo de errores\n// Principio SRP: Una sola responsabilidad - respuesta consolidada\n\nconst recoveryPlan = $input.first().json;\nconst autoRecoveryTriggered = $('Iniciar Recuperación Automática')?.first()?.json;\nconst manualEscalation = $('Preparar Escalación Manual')?.first()?.json;\n\n// Determinar el tipo de respuesta basado en el flujo seguido\nconst responseType = autoRecoveryTriggered ? 'auto_recovery_initiated' : 'manual_escalation_created';\n\n// Generar respuesta final estandarizada\nconst finalResponse = {\n  status: 'error_handled',\n  error_handling_summary: {\n    error_id: recoveryPlan.error_reference.error_id,\n    category: recoveryPlan.error_reference.category,\n    severity: recoveryPlan.error_reference.severity,\n    handling_approach: responseType,\n    handled_at: new Date().toISOString()\n  },\n  \n  user_facing_info: {\n    message: recoveryPlan.user_experience.show_progress_indicator ? \n      'Intentando recuperación automática...' : \n      'Error reportado al equipo técnico',\n    \n    estimated_resolution: recoveryPlan.user_experience.estimated_resolution,\n    \n    user_actions_available: {\n      can_retry: recoveryPlan.recovery_strategy.can_auto_recover,\n      can_use_alternatives: recoveryPlan.user_experience.provide_alternatives,\n      should_wait: autoRecoveryTriggered ? true : false,\n      should_contact_support: manualEscalation ? true : false\n    }\n  },\n  \n  technical_summary: {\n    recovery_strategy_applied: recoveryPlan.recovery_strategy.can_auto_recover,\n    fallback_workflows_triggered: recoveryPlan.recovery_strategy.fallback_workflows,\n    manual_intervention_required: manualEscalation ? true : false,\n    \n    tracking_info: {\n      log_id: recoveryPlan.error_reference.log_id,\n      incident_id: manualEscalation?.incident_id || null,\n      recovery_coordinator: 'error-handler-utility'\n    }\n  },\n  \n  monitoring_data: {\n    error_category_stats: recoveryPlan.error_reference.category,\n    severity_distribution: recoveryPlan.error_reference.severity,\n    auto_recovery_success_rate: autoRecoveryTriggered ? 'pending' : 'not_applicable',\n    manual_escalation_frequency: manualEscalation ? 'incremented' : 'unchanged'\n  },\n  \n  next_steps: {\n    immediate: autoRecoveryTriggered ? \n      'Monitoring auto-recovery progress' : \n      'Waiting for manual intervention',\n    \n    follow_up: {\n      check_status_in: autoRecoveryTriggered ? '2 minutos' : '15 minutos',\n      escalate_if_unresolved: autoRecoveryTriggered ? '10 minutos' : '1 hora'\n    }\n  }\n};\n\nconsole.log('Manejo de error completado:', {\n  errorId: finalResponse.error_handling_summary.error_id,\n  handlingApproach: finalResponse.error_handling_summary.handling_approach,\n  userCanRetry: finalResponse.user_facing_info.user_actions_available.can_retry,\n  manualInterventionRequired: finalResponse.technical_summary.manual_intervention_required\n});\n\nreturn [{ json: finalResponse }];"
      },
      "id": "generate-final-response",
      "name": "Generar Respuesta Final",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2000, 400]
    }
  ],
  "connections": {
    "Trigger del Workflow": {
      "main": [
        [
          {
            "node": "Categorizar Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Categorizar Error": {
      "main": [
        [
          {
            "node": "¿Severidad Alta?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¿Severidad Alta?": {
      "main": [
        [
          {
            "node": "Registrar Error en BD",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Registrar Error en BD",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Registrar Error en BD": {
      "main": [
        [
          {
            "node": "Disparar Alerta Urgente",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generar Plan Recuperación",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Disparar Alerta Urgente": {
      "main": [
        [
          {
            "node": "Generar Respuesta Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generar Plan Recuperación": {
      "main": [
        [
          {
            "node": "¿Recuperación Automática?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¿Recuperación Automática?": {
      "main": [
        [
          {
            "node": "Iniciar Recuperación Automática",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar Escalación Manual",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Iniciar Recuperación Automática": {
      "main": [
        [
          {
            "node": "Generar Respuesta Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Escalación Manual": {
      "main": [
        [
          {
            "node": "Notificar Incidente",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notificar Incidente": {
      "main": [
        [
          {
            "node": "Generar Respuesta Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  }
}