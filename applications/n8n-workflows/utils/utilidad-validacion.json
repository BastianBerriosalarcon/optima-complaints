{
  "name": "Utils - Validation Utility", 
  "description": "Workflow utilitario enfocado en validaciones estandarizadas reutilizables. Principio SRP: Una sola responsabilidad - validaciones centralizadas.",
  "tags": ["utils", "validation", "reusable", "srp", "standards"],
  "nodes": [
    {
      "parameters": {
        "workflowId": "{{ $json.workflowId }}"
      },
      "id": "workflow-trigger",
      "name": "Trigger del Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en coordinar validaciones según tipo solicitado\n// Principio SRP: Una sola responsabilidad - routing de validaciones\n\nconst validationRequest = $input.first().json;\n\n// Validar estructura básica de la solicitud\nif (!validationRequest.validation_type) {\n  throw new Error('validation_type es requerido');\n}\n\nif (!validationRequest.data_to_validate) {\n  throw new Error('data_to_validate es requerido');\n}\n\n// Tipos de validación soportados\nconst supportedValidations = [\n  'tenant_data',\n  'customer_data', \n  'complaint_data',\n  'survey_data',\n  'lead_data',\n  'email_data',\n  'phone_data',\n  'uuid_data',\n  'ai_config',\n  'document_upload'\n];\n\nif (!supportedValidations.includes(validationRequest.validation_type)) {\n  throw new Error(`Tipo de validación no soportado: ${validationRequest.validation_type}. Soportados: ${supportedValidations.join(', ')}`);\n}\n\n// Preparar contexto de validación\nconst validationContext = {\n  validation_id: `VAL-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,\n  validation_type: validationRequest.validation_type,\n  data_to_validate: validationRequest.data_to_validate,\n  validation_rules: validationRequest.validation_rules || {},\n  strict_mode: validationRequest.strict_mode || false,\n  tenant_context: validationRequest.tenant_context || null,\n  \n  // Metadatos\n  validation_initiated_at: new Date().toISOString(),\n  requesting_workflow: validationRequest.requesting_workflow || 'unknown',\n  requesting_node: validationRequest.requesting_node || 'unknown'\n};\n\nconsole.log('Validación iniciada:', {\n  validationId: validationContext.validation_id,\n  type: validationContext.validation_type,\n  strictMode: validationContext.strict_mode,\n  requestingWorkflow: validationContext.requesting_workflow\n});\n\nreturn [{ json: validationContext }];"
      },
      "id": "coordinate-validation",
      "name": "Coordinar Validación",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.validation_type }}",
              "rightValue": "tenant_data",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "leftValue": "={{ $json.validation_type }}",
              "rightValue": "customer_data",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "leftValue": "={{ $json.validation_type }}",
              "rightValue": "complaint_data",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combineOperation": "any"
        }
      },
      "id": "route-business-validation",
      "name": "¿Validación de Negocio?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en validaciones de datos de negocio\n// Principio SRP: Una sola responsabilidad - validar datos de negocio\n\nconst context = $input.first().json;\nconst data = context.data_to_validate;\nconst type = context.validation_type;\nconst rules = context.validation_rules;\nconst strictMode = context.strict_mode;\n\nlet validationResults = {\n  is_valid: true,\n  errors: [],\n  warnings: [],\n  normalized_data: {},\n  validation_details: {}\n};\n\ntry {\n  switch (type) {\n    case 'tenant_data':\n      // Validaciones para datos de concesionario\n      \n      // Campo obligatorio: tenant_id\n      if (!data.tenant_id) {\n        validationResults.errors.push('tenant_id es requerido');\n      } else {\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        if (!uuidRegex.test(data.tenant_id)) {\n          validationResults.errors.push('tenant_id debe ser un UUID válido');\n        } else {\n          validationResults.normalized_data.tenant_id = data.tenant_id.toLowerCase();\n        }\n      }\n      \n      // Campo obligatorio: tenant_name\n      if (!data.tenant_name || data.tenant_name.trim().length === 0) {\n        validationResults.errors.push('tenant_name es requerido y no puede estar vacío');\n      } else {\n        validationResults.normalized_data.tenant_name = data.tenant_name.trim();\n      }\n      \n      // Validación opcional: teléfono principal\n      if (data.telefono_principal) {\n        const phoneRegex = /^\\+56[0-9]{8,9}$/;\n        if (!phoneRegex.test(data.telefono_principal)) {\n          if (strictMode) {\n            validationResults.errors.push('telefono_principal debe tener formato +56XXXXXXXX');\n          } else {\n            validationResults.warnings.push('telefono_principal no tiene formato estándar chileno');\n            validationResults.normalized_data.telefono_principal = data.telefono_principal;\n          }\n        } else {\n          validationResults.normalized_data.telefono_principal = data.telefono_principal;\n        }\n      }\n      \n      validationResults.validation_details.tenant_validation = 'completed';\n      break;\n      \n    case 'customer_data':\n      // Validaciones para datos de cliente\n      \n      // Nombre del cliente\n      if (!data.nombre || data.nombre.trim().length < 2) {\n        validationResults.errors.push('nombre del cliente debe tener al menos 2 caracteres');\n      } else {\n        validationResults.normalized_data.nombre = data.nombre.trim();\n      }\n      \n      // Teléfono del cliente\n      if (data.telefono) {\n        // Normalizar formato de teléfono chileno\n        let normalizedPhone = data.telefono.replace(/[^+0-9]/g, '');\n        \n        // Si no tiene código de país, agregar +56\n        if (normalizedPhone.startsWith('9') && normalizedPhone.length === 9) {\n          normalizedPhone = '+56' + normalizedPhone;\n        } else if (normalizedPhone.startsWith('569')) {\n          normalizedPhone = '+' + normalizedPhone;\n        }\n        \n        const phoneRegex = /^\\+56[0-9]{8,9}$/;\n        if (!phoneRegex.test(normalizedPhone)) {\n          if (strictMode) {\n            validationResults.errors.push('telefono debe ser un número válido chileno');\n          } else {\n            validationResults.warnings.push('telefono no pudo ser normalizado automáticamente');\n            validationResults.normalized_data.telefono = data.telefono;\n          }\n        } else {\n          validationResults.normalized_data.telefono = normalizedPhone;\n        }\n      }\n      \n      // Email del cliente\n      if (data.email) {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(data.email)) {\n          validationResults.errors.push('email no tiene formato válido');\n        } else {\n          validationResults.normalized_data.email = data.email.toLowerCase().trim();\n        }\n      }\n      \n      // RUT del cliente\n      if (data.rut) {\n        // Normalizar RUT (remover puntos y guiones)\n        const cleanRut = data.rut.replace(/[^0-9kK]/g, '');\n        \n        if (cleanRut.length < 8 || cleanRut.length > 9) {\n          validationResults.errors.push('RUT debe tener entre 8 y 9 caracteres');\n        } else {\n          // Formatear RUT estándar: XX.XXX.XXX-X\n          const rutDigits = cleanRut.slice(0, -1);\n          const rutDv = cleanRut.slice(-1).toUpperCase();\n          \n          if (rutDigits.length >= 7) {\n            const formattedRut = rutDigits.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1.') + '-' + rutDv;\n            validationResults.normalized_data.rut = formattedRut;\n          } else {\n            validationResults.normalized_data.rut = rutDigits + '-' + rutDv;\n          }\n        }\n      }\n      \n      validationResults.validation_details.customer_validation = 'completed';\n      break;\n      \n    case 'complaint_data':\n      // Validaciones para datos de reclamo\n      \n      // Texto del reclamo\n      if (!data.complaint_text || data.complaint_text.trim().length < 10) {\n        validationResults.errors.push('texto del reclamo debe tener al menos 10 caracteres');\n      } else {\n        validationResults.normalized_data.complaint_text = data.complaint_text.trim();\n      }\n      \n      // Categoría del reclamo\n      const validCategories = ['servicio', 'ventas', 'producto', 'facturacion', 'otro'];\n      if (data.categoria && !validCategories.includes(data.categoria)) {\n        if (strictMode) {\n          validationResults.errors.push(`categoría debe ser una de: ${validCategories.join(', ')}`);\n        } else {\n          validationResults.warnings.push('categoría no está en lista predefinida');\n          validationResults.normalized_data.categoria = data.categoria || 'otro';\n        }\n      } else {\n        validationResults.normalized_data.categoria = data.categoria || 'otro';\n      }\n      \n      // Urgencia del reclamo\n      const validUrgencies = ['baja', 'media', 'alta'];\n      if (data.urgencia && !validUrgencies.includes(data.urgencia)) {\n        validationResults.normalized_data.urgencia = 'media'; // valor por defecto\n        validationResults.warnings.push('urgencia no válida, usando valor por defecto: media');\n      } else {\n        validationResults.normalized_data.urgencia = data.urgencia || 'media';\n      }\n      \n      // Black Alert\n      validationResults.normalized_data.black_alert = Boolean(data.black_alert);\n      \n      validationResults.validation_details.complaint_validation = 'completed';\n      break;\n  }\n  \n  // Determinar si la validación pasó\n  validationResults.is_valid = validationResults.errors.length === 0;\n  \n} catch (error) {\n  validationResults.is_valid = false;\n  validationResults.errors.push(`Error interno de validación: ${error.message}`);\n}\n\n// Agregar metadatos de validación\nvalidationResults.validation_metadata = {\n  validation_id: context.validation_id,\n  validation_type: type,\n  strict_mode: strictMode,\n  validated_at: new Date().toISOString(),\n  rules_applied: rules,\n  original_data_size: JSON.stringify(data).length,\n  normalized_data_size: JSON.stringify(validationResults.normalized_data).length\n};\n\nconsole.log('Validación de negocio completada:', {\n  validationId: context.validation_id,\n  type: type,\n  isValid: validationResults.is_valid,\n  errorsCount: validationResults.errors.length,\n  warningsCount: validationResults.warnings.length\n});\n\nreturn [{ json: validationResults }];"
      },
      "id": "validate-business-data",
      "name": "Validar Datos Negocio",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en validaciones técnicas y de formato\n// Principio SRP: Una sola responsabilidad - validar datos técnicos\n\nconst context = $input.first().json;\nconst data = context.data_to_validate;\nconst type = context.validation_type;\nconst rules = context.validation_rules;\nconst strictMode = context.strict_mode;\n\nlet validationResults = {\n  is_valid: true,\n  errors: [],\n  warnings: [],\n  normalized_data: {},\n  validation_details: {}\n};\n\ntry {\n  switch (type) {\n    case 'email_data':\n      // Validación especializada de emails\n      if (!data.email) {\n        validationResults.errors.push('email es requerido');\n      } else {\n        const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n        \n        if (!emailRegex.test(data.email)) {\n          validationResults.errors.push('formato de email inválido');\n        } else {\n          validationResults.normalized_data.email = data.email.toLowerCase().trim();\n          \n          // Validaciones adicionales opcionales\n          if (data.email.length > 254) {\n            validationResults.errors.push('email excede la longitud máxima (254 caracteres)');\n          }\n          \n          // Lista de dominios temporales/sospechosos (opcional)\n          const suspiciousDomains = ['10minutemail.com', 'tempmail.org', 'guerrillamail.com'];\n          const domain = data.email.split('@')[1];\n          if (suspiciousDomains.includes(domain)) {\n            if (strictMode) {\n              validationResults.errors.push('dominio de email no permitido');\n            } else {\n              validationResults.warnings.push('dominio de email temporal detectado');\n            }\n          }\n        }\n      }\n      \n      validationResults.validation_details.email_validation = 'completed';\n      break;\n      \n    case 'phone_data':\n      // Validación especializada de teléfonos\n      if (!data.phone) {\n        validationResults.errors.push('teléfono es requerido');\n      } else {\n        // Normalizar número (remover espacios, guiones, paréntesis)\n        let normalizedPhone = data.phone.replace(/[^+0-9]/g, '');\n        \n        // Detectar y normalizar formatos chilenos\n        if (normalizedPhone.startsWith('9') && normalizedPhone.length === 9) {\n          normalizedPhone = '+56' + normalizedPhone;\n        } else if (normalizedPhone.startsWith('569')) {\n          normalizedPhone = '+' + normalizedPhone;\n        } else if (normalizedPhone.startsWith('56') && normalizedPhone.length === 11) {\n          normalizedPhone = '+' + normalizedPhone;\n        }\n        \n        // Validar formato final\n        const phoneRegex = /^\\+56[0-9]{8,9}$/;\n        if (!phoneRegex.test(normalizedPhone)) {\n          validationResults.errors.push('formato de teléfono inválido (esperado: +56XXXXXXXXX)');\n        } else {\n          validationResults.normalized_data.phone = normalizedPhone;\n          \n          // Validar que sea número móvil (opcional)\n          if (rules.mobile_only && !normalizedPhone.startsWith('+569')) {\n            if (strictMode) {\n              validationResults.errors.push('solo se permiten números móviles');\n            } else {\n              validationResults.warnings.push('número no es móvil');\n            }\n          }\n        }\n      }\n      \n      validationResults.validation_details.phone_validation = 'completed';\n      break;\n      \n    case 'uuid_data':\n      // Validación especializada de UUIDs\n      if (!data.uuid) {\n        validationResults.errors.push('UUID es requerido');\n      } else {\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        \n        if (!uuidRegex.test(data.uuid)) {\n          validationResults.errors.push('formato de UUID inválido');\n        } else {\n          validationResults.normalized_data.uuid = data.uuid.toLowerCase();\n          \n          // Extraer versión del UUID\n          const version = parseInt(data.uuid.charAt(14), 16);\n          validationResults.validation_details.uuid_version = version;\n          \n          // Validar versión específica si se requiere\n          if (rules.required_version && version !== rules.required_version) {\n            validationResults.errors.push(`UUID debe ser versión ${rules.required_version}, encontrada versión ${version}`);\n          }\n        }\n      }\n      \n      validationResults.validation_details.uuid_validation = 'completed';\n      break;\n      \n    case 'ai_config':\n      // Validación de configuración de IA\n      \n      // Modelo de IA\n      const validModels = ['gemini-2.5-pro', 'gemini-embedding-001', 'gemini-1.5-pro'];\n      if (!data.modelo_ia || !validModels.includes(data.modelo_ia)) {\n        if (strictMode) {\n          validationResults.errors.push(`modelo_ia debe ser uno de: ${validModels.join(', ')}`);\n        } else {\n          validationResults.warnings.push('modelo_ia no está en lista recomendada');\n          validationResults.normalized_data.modelo_ia = data.modelo_ia || 'gemini-2.5-pro';\n        }\n      } else {\n        validationResults.normalized_data.modelo_ia = data.modelo_ia;\n      }\n      \n      // Temperatura\n      const temperature = parseFloat(data.temperatura);\n      if (isNaN(temperature) || temperature < 0 || temperature > 2) {\n        validationResults.errors.push('temperatura debe ser un número entre 0 y 2');\n      } else {\n        validationResults.normalized_data.temperatura = temperature;\n      }\n      \n      // Max tokens\n      const maxTokens = parseInt(data.max_tokens);\n      if (isNaN(maxTokens) || maxTokens < 1 || maxTokens > 8192) {\n        validationResults.errors.push('max_tokens debe ser un número entre 1 y 8192');\n      } else {\n        validationResults.normalized_data.max_tokens = maxTokens;\n      }\n      \n      validationResults.validation_details.ai_config_validation = 'completed';\n      break;\n      \n    case 'document_upload':\n      // Validación de documentos subidos\n      \n      // Título del documento\n      if (!data.document_title || data.document_title.trim().length < 3) {\n        validationResults.errors.push('título del documento debe tener al menos 3 caracteres');\n      } else {\n        validationResults.normalized_data.document_title = data.document_title.trim();\n      }\n      \n      // Contenido del documento\n      if (!data.file_content) {\n        validationResults.errors.push('contenido del documento es requerido');\n      } else {\n        const contentLength = data.file_content.length;\n        \n        if (contentLength < 100) {\n          validationResults.errors.push('contenido del documento debe tener al menos 100 caracteres');\n        } else if (contentLength > 1000000) { // 1MB\n          validationResults.errors.push('contenido del documento excede el tamaño máximo (1MB)');\n        } else {\n          validationResults.normalized_data.file_content = data.file_content;\n          validationResults.validation_details.content_size_bytes = contentLength;\n        }\n      }\n      \n      // Tipo MIME (opcional)\n      if (data.mime_type) {\n        const allowedMimeTypes = ['text/plain', 'text/markdown', 'application/pdf', 'application/msword'];\n        if (!allowedMimeTypes.includes(data.mime_type)) {\n          if (strictMode) {\n            validationResults.errors.push(`tipo MIME no soportado: ${data.mime_type}`);\n          } else {\n            validationResults.warnings.push('tipo MIME no está en lista recomendada');\n            validationResults.normalized_data.mime_type = data.mime_type;\n          }\n        } else {\n          validationResults.normalized_data.mime_type = data.mime_type;\n        }\n      }\n      \n      validationResults.validation_details.document_validation = 'completed';\n      break;\n  }\n  \n  // Determinar si la validación pasó\n  validationResults.is_valid = validationResults.errors.length === 0;\n  \n} catch (error) {\n  validationResults.is_valid = false;\n  validationResults.errors.push(`Error interno de validación técnica: ${error.message}`);\n}\n\n// Agregar metadatos de validación\nvalidationResults.validation_metadata = {\n  validation_id: context.validation_id,\n  validation_type: type,\n  strict_mode: strictMode,\n  validated_at: new Date().toISOString(),\n  rules_applied: rules,\n  original_data_size: JSON.stringify(data).length,\n  normalized_data_size: JSON.stringify(validationResults.normalized_data).length\n};\n\nconsole.log('Validación técnica completada:', {\n  validationId: context.validation_id,\n  type: type,\n  isValid: validationResults.is_valid,\n  errorsCount: validationResults.errors.length,\n  warningsCount: validationResults.warnings.length\n});\n\nreturn [{ json: validationResults }];"
      },
      "id": "validate-technical-data",
      "name": "Validar Datos Técnicos",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 400]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en generar respuesta final de validación\n// Principio SRP: Una sola responsabilidad - consolidar resultados\n\nconst businessValidation = $('Validar Datos Negocio')?.first()?.json;\nconst technicalValidation = $('Validar Datos Técnicos')?.first()?.json;\nconst coordinationData = $('Coordinar Validación').first().json;\n\n// Determinar cuál validación se ejecutó\nconst executedValidation = businessValidation || technicalValidation;\n\nif (!executedValidation) {\n  throw new Error('No se ejecutó ninguna validación');\n}\n\n// Generar respuesta consolidada\nconst finalValidationResult = {\n  // Estado general\n  validation_status: executedValidation.is_valid ? 'passed' : 'failed',\n  \n  // Detalles de la validación\n  validation_summary: {\n    validation_id: executedValidation.validation_metadata.validation_id,\n    validation_type: executedValidation.validation_metadata.validation_type,\n    strict_mode: executedValidation.validation_metadata.strict_mode,\n    executed_path: businessValidation ? 'business_validation' : 'technical_validation',\n    processed_at: executedValidation.validation_metadata.validated_at\n  },\n  \n  // Resultados de validación\n  validation_results: {\n    is_valid: executedValidation.is_valid,\n    total_errors: executedValidation.errors.length,\n    total_warnings: executedValidation.warnings.length,\n    \n    errors: executedValidation.errors,\n    warnings: executedValidation.warnings,\n    \n    // Datos normalizados listos para usar\n    normalized_data: executedValidation.normalized_data,\n    \n    // Detalles técnicos\n    validation_details: executedValidation.validation_details\n  },\n  \n  // Métricas de validación\n  validation_metrics: {\n    original_data_size: executedValidation.validation_metadata.original_data_size,\n    normalized_data_size: executedValidation.validation_metadata.normalized_data_size,\n    data_reduction_percentage: Math.round(\n      ((executedValidation.validation_metadata.original_data_size - executedValidation.validation_metadata.normalized_data_size) / \n       executedValidation.validation_metadata.original_data_size) * 100\n    ),\n    rules_applied: Object.keys(executedValidation.validation_metadata.rules_applied || {}).length\n  },\n  \n  // Recomendaciones para el flujo que consume\n  recommendations: {\n    can_proceed: executedValidation.is_valid,\n    suggested_action: executedValidation.is_valid ? \n      'proceed_with_normalized_data' : \n      'fix_errors_and_retry',\n    \n    // Si hay warnings pero no errors, se puede proceder con precaución\n    proceed_with_warnings: !executedValidation.is_valid && executedValidation.errors.length === 0 && executedValidation.warnings.length > 0,\n    \n    // Datos listos para el siguiente paso\n    data_for_next_step: executedValidation.is_valid ? executedValidation.normalized_data : null,\n    \n    // Errores que necesitan corrección\n    critical_errors: executedValidation.errors.filter(error => \n      error.includes('requerido') || error.includes('UUID') || error.includes('formato')\n    )\n  },\n  \n  // Contexto original para trazabilidad\n  original_request: {\n    requesting_workflow: coordinationData.requesting_workflow,\n    requesting_node: coordinationData.requesting_node,\n    tenant_context: coordinationData.tenant_context\n  }\n};\n\n// Log final de validación\nconsole.log('Validación finalizada:', {\n  validationId: finalValidationResult.validation_summary.validation_id,\n  type: finalValidationResult.validation_summary.validation_type,\n  status: finalValidationResult.validation_status,\n  canProceed: finalValidationResult.recommendations.can_proceed,\n  errorsCount: finalValidationResult.validation_results.total_errors,\n  warningsCount: finalValidationResult.validation_results.total_warnings\n});\n\nreturn [{ json: finalValidationResult }];"
      },
      "id": "consolidate-validation-results",
      "name": "Consolidar Resultados",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 300]
    }
  ],
  "connections": {
    "Trigger del Workflow": {
      "main": [
        [
          {
            "node": "Coordinar Validación",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Coordinar Validación": {
      "main": [
        [
          {
            "node": "¿Validación de Negocio?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¿Validación de Negocio?": {
      "main": [
        [
          {
            "node": "Validar Datos Negocio",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validar Datos Técnicos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Datos Negocio": {
      "main": [
        [
          {
            "node": "Consolidar Resultados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Datos Técnicos": {
      "main": [
        [
          {
            "node": "Consolidar Resultados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  }
}