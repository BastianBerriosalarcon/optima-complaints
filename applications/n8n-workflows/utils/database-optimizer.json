{
  "name": "Utils - Database Optimizer",
  "description": "Workflow utilitario enfocado en optimización de operaciones de base de datos. Principio SRP: Una sola responsabilidad - optimizar consultas y operaciones BD.",
  "tags": ["utils", "database", "performance", "optimization", "srp"],
  "nodes": [
    {
      "parameters": {
        "workflowId": "{{ $json.workflowId }}"
      },
      "id": "workflow-trigger",
      "name": "Trigger del Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en analizar y optimizar operaciones de BD\n// Principio SRP: Una sola responsabilidad - análisis de queries\n\nconst operationRequest = $input.first().json;\n\n// Validar estructura de la solicitud\nif (!operationRequest.operation_type) {\n  throw new Error('operation_type es requerido');\n}\n\nif (!operationRequest.operation_data) {\n  throw new Error('operation_data es requerido');\n}\n\n// Tipos de optimización soportados\nconst supportedOperations = [\n  'bulk_insert',\n  'bulk_update', \n  'batch_query',\n  'optimized_search',\n  'cache_query',\n  'paginated_query',\n  'analytics_query'\n];\n\nif (!supportedOperations.includes(operationRequest.operation_type)) {\n  throw new Error(`Tipo de operación no soportado: ${operationRequest.operation_type}. Soportados: ${supportedOperations.join(', ')}`);\n}\n\n// Analizar y optimizar según el tipo de operación\nlet optimizationStrategy = {\n  operation_id: `OPT-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,\n  operation_type: operationRequest.operation_type,\n  optimization_applied: [],\n  performance_config: {},\n  execution_plan: []\n};\n\nswitch (operationRequest.operation_type) {\n  case 'bulk_insert':\n    // Optimización para inserciones masivas\n    const insertData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'batch_processing',\n      'transaction_grouping',\n      'index_hint_disable'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      batch_size: Math.min(insertData.records?.length || 100, 1000), // Max 1000 por lote\n      use_transaction: true,\n      disable_triggers: insertData.disable_triggers || false,\n      parallel_processing: insertData.records?.length > 5000\n    };\n    \n    // Dividir en lotes si es necesario\n    if (insertData.records && insertData.records.length > 1000) {\n      const batches = [];\n      for (let i = 0; i < insertData.records.length; i += 1000) {\n        batches.push(insertData.records.slice(i, i + 1000));\n      }\n      optimizationStrategy.execution_plan = batches.map((batch, index) => ({\n        step: index + 1,\n        type: 'batch_insert',\n        records_count: batch.length,\n        data: batch\n      }));\n    } else {\n      optimizationStrategy.execution_plan = [{\n        step: 1,\n        type: 'single_batch_insert',\n        records_count: insertData.records?.length || 0,\n        data: insertData.records || []\n      }];\n    }\n    break;\n    \n  case 'bulk_update':\n    // Optimización para actualizaciones masivas\n    const updateData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'where_clause_optimization',\n      'index_usage',\n      'batch_processing'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      use_index_hints: true,\n      batch_size: 500,\n      use_case_when: updateData.updates?.length > 10\n    };\n    \n    optimizationStrategy.execution_plan = [{\n      step: 1,\n      type: 'optimized_bulk_update',\n      table: updateData.table,\n      updates_count: updateData.updates?.length || 0,\n      where_conditions: updateData.where_conditions || {}\n    }];\n    break;\n    \n  case 'batch_query':\n    // Optimización para múltiples consultas\n    const queryData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'query_consolidation',\n      'join_optimization',\n      'result_caching'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      consolidate_similar_queries: true,\n      use_prepared_statements: true,\n      enable_query_cache: true,\n      parallel_execution: queryData.queries?.length > 5\n    };\n    \n    // Agrupar queries similares\n    const groupedQueries = {};\n    (queryData.queries || []).forEach((query, index) => {\n      const queryKey = query.table + '_' + query.operation;\n      if (!groupedQueries[queryKey]) {\n        groupedQueries[queryKey] = [];\n      }\n      groupedQueries[queryKey].push({ ...query, original_index: index });\n    });\n    \n    optimizationStrategy.execution_plan = Object.keys(groupedQueries).map((key, index) => ({\n      step: index + 1,\n      type: 'consolidated_query_group',\n      query_group: key,\n      queries_count: groupedQueries[key].length,\n      queries: groupedQueries[key]\n    }));\n    break;\n    \n  case 'optimized_search':\n    // Optimización para búsquedas complejas\n    const searchData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'full_text_search',\n      'index_selection',\n      'result_limiting'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      use_full_text_index: searchData.text_search || false,\n      limit_results: searchData.limit || 100,\n      use_explain_plan: true,\n      enable_pagination: true\n    };\n    \n    optimizationStrategy.execution_plan = [{\n      step: 1,\n      type: 'optimized_search_query',\n      search_terms: searchData.search_terms || [],\n      filters: searchData.filters || {},\n      sort_criteria: searchData.sort || [],\n      limit: searchData.limit || 100\n    }];\n    break;\n    \n  case 'cache_query':\n    // Optimización con cache\n    const cacheData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'redis_caching',\n      'query_fingerprinting',\n      'ttl_optimization'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      cache_ttl: cacheData.ttl || 300, // 5 minutos por defecto\n      cache_key_prefix: cacheData.cache_prefix || 'query_cache',\n      enable_cache_warming: cacheData.warm_cache || false,\n      cache_invalidation_strategy: 'time_based'\n    };\n    \n    optimizationStrategy.execution_plan = [{\n      step: 1,\n      type: 'cached_query_execution',\n      cache_key: `${optimizationStrategy.performance_config.cache_key_prefix}:${operationRequest.operation_data.query_hash || 'auto'}`,\n      fallback_query: cacheData.query || {},\n      ttl: optimizationStrategy.performance_config.cache_ttl\n    }];\n    break;\n    \n  case 'paginated_query':\n    // Optimización para consultas paginadas\n    const paginationData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'cursor_pagination',\n      'index_optimization',\n      'count_optimization'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      page_size: Math.min(paginationData.page_size || 50, 1000),\n      use_cursor_pagination: paginationData.use_cursor || true,\n      optimize_count_query: true,\n      enable_total_count: paginationData.include_total || false\n    };\n    \n    optimizationStrategy.execution_plan = [{\n      step: 1,\n      type: 'paginated_query_execution',\n      page_size: optimizationStrategy.performance_config.page_size,\n      cursor_field: paginationData.cursor_field || 'id',\n      cursor_value: paginationData.cursor_value || null,\n      sort_direction: paginationData.sort_direction || 'ASC'\n    }];\n    break;\n    \n  case 'analytics_query':\n    // Optimización para queries analíticas\n    const analyticsData = operationRequest.operation_data;\n    \n    optimizationStrategy.optimization_applied = [\n      'aggregation_optimization',\n      'materialized_views',\n      'column_store_hints'\n    ];\n    \n    optimizationStrategy.performance_config = {\n      use_materialized_views: true,\n      parallel_aggregation: analyticsData.large_dataset || false,\n      enable_pushdown: true,\n      optimize_group_by: true\n    };\n    \n    optimizationStrategy.execution_plan = [{\n      step: 1,\n      type: 'analytics_query_execution',\n      aggregations: analyticsData.aggregations || [],\n      time_range: analyticsData.time_range || {},\n      grouping_fields: analyticsData.group_by || []\n    }];\n    break;\n}\n\n// Agregar metadatos de optimización\noptimizationStrategy.optimization_metadata = {\n  optimization_id: optimizationStrategy.operation_id,\n  requested_at: new Date().toISOString(),\n  tenant_context: operationRequest.tenant_context || null,\n  requesting_workflow: operationRequest.requesting_workflow || 'unknown',\n  estimated_performance_gain: '20-50%', // Estimación basada en tipo de operación\n  complexity_score: optimizationStrategy.execution_plan.length * optimizationStrategy.optimization_applied.length\n};\n\nconsole.log('Estrategia de optimización generada:', {\n  operationId: optimizationStrategy.operation_id,\n  type: optimizationStrategy.operation_type,\n  optimizationsApplied: optimizationStrategy.optimization_applied.length,\n  executionSteps: optimizationStrategy.execution_plan.length,\n  complexityScore: optimizationStrategy.optimization_metadata.complexity_score\n});\n\nreturn [{ json: optimizationStrategy }];"
      },
      "id": "analyze-optimization",
      "name": "Analizar Optimización",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.operation_type }}",
              "operation": "equal",
              "value2": "bulk_insert"
            }
          ]
        }
      },
      "id": "check-bulk-operation",
      "name": "¿Operación Masiva?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en ejecutar operaciones masivas optimizadas\n// Principio SRP: Una sola responsabilidad - ejecutar operaciones bulk\n\nconst strategy = $input.first().json;\nconst executionPlan = strategy.execution_plan;\nconst performanceConfig = strategy.performance_config;\n\n// Preparar queries optimizadas para operaciones masivas\nlet optimizedQueries = [];\nlet executionResults = [];\n\nif (strategy.operation_type === 'bulk_insert') {\n  // Optimización para inserciones masivas\n  executionPlan.forEach((step, index) => {\n    if (step.data && step.data.length > 0) {\n      // Generar query de inserción por lotes\n      const firstRecord = step.data[0];\n      const columns = Object.keys(firstRecord).join(', ');\n      \n      // Construir VALUES clause optimizada\n      const valuesClause = step.data.map(record => {\n        const values = Object.values(record).map(value => {\n          if (typeof value === 'string') {\n            return `'${value.replace(/'/g, \"''\")}'`; // Escape comillas\n          } else if (value === null || value === undefined) {\n            return 'NULL';\n          } else {\n            return value;\n          }\n        }).join(', ');\n        return `(${values})`;\n      }).join(', ');\n      \n      const optimizedQuery = {\n        step_number: step.step,\n        query_type: 'bulk_insert',\n        query: `INSERT INTO ${strategy.operation_data?.table || 'target_table'} (${columns}) VALUES ${valuesClause}`,\n        records_count: step.data.length,\n        estimated_execution_time: `${Math.ceil(step.data.length / 100)} segundos`,\n        performance_hints: [\n          'USE INDEX (PRIMARY)',\n          'SET autocommit=0',\n          'SET unique_checks=0',\n          'SET foreign_key_checks=0'\n        ]\n      };\n      \n      optimizedQueries.push(optimizedQuery);\n    }\n  });\n} else if (strategy.operation_type === 'bulk_update') {\n  // Optimización para actualizaciones masivas\n  const updateData = strategy.operation_data;\n  \n  if (performanceConfig.use_case_when && updateData.updates?.length > 10) {\n    // Usar CASE WHEN para múltiples updates\n    const setClauses = Object.keys(updateData.updates[0].set || {}).map(column => {\n      const caseWhen = updateData.updates.map(update => {\n        const whereClause = Object.entries(update.where || {}).map(([key, value]) => `${key} = '${value}'`).join(' AND ');\n        const setValue = update.set[column];\n        return `WHEN ${whereClause} THEN '${setValue}'`;\n      }).join(' ');\n      \n      return `${column} = CASE ${caseWhen} ELSE ${column} END`;\n    }).join(', ');\n    \n    const allWhereConditions = updateData.updates.map(update => {\n      return Object.entries(update.where || {}).map(([key, value]) => `${key} = '${value}'`).join(' AND ');\n    }).join(' OR ');\n    \n    const optimizedQuery = {\n      step_number: 1,\n      query_type: 'bulk_update_case_when',\n      query: `UPDATE ${updateData.table} SET ${setClauses} WHERE (${allWhereConditions})`,\n      records_count: updateData.updates.length,\n      estimated_execution_time: `${Math.ceil(updateData.updates.length / 200)} segundos`,\n      performance_hints: [\n        'USE INDEX FOR WHERE clause',\n        'SET autocommit=0'\n      ]\n    };\n    \n    optimizedQueries.push(optimizedQuery);\n  } else {\n    // Updates individuales optimizados\n    updateData.updates?.forEach((update, index) => {\n      const setClause = Object.entries(update.set || {}).map(([key, value]) => `${key} = '${value}'`).join(', ');\n      const whereClause = Object.entries(update.where || {}).map(([key, value]) => `${key} = '${value}'`).join(' AND ');\n      \n      const optimizedQuery = {\n        step_number: index + 1,\n        query_type: 'optimized_update',\n        query: `UPDATE ${updateData.table} SET ${setClause} WHERE ${whereClause}`,\n        records_count: 1,\n        estimated_execution_time: '0.1 segundos'\n      };\n      \n      optimizedQueries.push(optimizedQuery);\n    });\n  }\n}\n\n// Generar plan de ejecución optimizado\nconst optimizedExecutionPlan = {\n  operation_id: strategy.operation_id,\n  optimization_summary: {\n    total_queries: optimizedQueries.length,\n    total_records_affected: optimizedQueries.reduce((sum, q) => sum + q.records_count, 0),\n    estimated_total_time: optimizedQueries.reduce((sum, q) => {\n      const timeStr = q.estimated_execution_time;\n      const seconds = parseFloat(timeStr.replace(' segundos', ''));\n      return sum + seconds;\n    }, 0) + ' segundos',\n    performance_optimizations: strategy.optimization_applied\n  },\n  \n  execution_sequence: optimizedQueries,\n  \n  performance_configuration: {\n    use_transaction: performanceConfig.use_transaction || false,\n    parallel_processing: performanceConfig.parallel_processing || false,\n    batch_size: performanceConfig.batch_size || 100,\n    enable_query_cache: false, // Deshabilitado para operaciones de escritura\n    connection_pooling: true\n  },\n  \n  monitoring_config: {\n    track_execution_time: true,\n    track_rows_affected: true,\n    track_deadlocks: true,\n    alert_on_long_running: true,\n    max_execution_time_minutes: 10\n  },\n  \n  rollback_strategy: {\n    use_savepoints: performanceConfig.use_transaction,\n    backup_before_execution: optimizedQueries.length > 10,\n    rollback_on_error: true\n  }\n};\n\nconsole.log('Plan de ejecución optimizado generado:', {\n  operationId: strategy.operation_id,\n  totalQueries: optimizedExecutionPlan.optimization_summary.total_queries,\n  totalRecords: optimizedExecutionPlan.optimization_summary.total_records_affected,\n  estimatedTime: optimizedExecutionPlan.optimization_summary.estimated_total_time,\n  useTransaction: optimizedExecutionPlan.performance_configuration.use_transaction\n});\n\nreturn [{ json: optimizedExecutionPlan }];"
      },
      "id": "execute-bulk-operations",
      "name": "Ejecutar Operaciones Masivas",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en ejecutar consultas optimizadas\n// Principio SRP: Una sola responsabilidad - ejecutar queries de lectura\n\nconst strategy = $input.first().json;\nconst executionPlan = strategy.execution_plan;\nconst performanceConfig = strategy.performance_config;\n\n// Preparar queries optimizadas para operaciones de lectura\nlet optimizedQueries = [];\n\nif (strategy.operation_type === 'optimized_search') {\n  // Optimización para búsquedas\n  const step = executionPlan[0];\n  \n  let baseQuery = `SELECT * FROM ${strategy.operation_data?.table || 'search_table'}`;\n  let whereConditions = [];\n  let orderByClause = '';\n  let limitClause = '';\n  \n  // Construir condiciones WHERE optimizadas\n  if (step.search_terms && step.search_terms.length > 0) {\n    if (performanceConfig.use_full_text_index) {\n      // Usar búsqueda de texto completo\n      const searchTerms = step.search_terms.join(' ');\n      whereConditions.push(`MATCH(content) AGAINST('${searchTerms}' IN NATURAL LANGUAGE MODE)`);\n    } else {\n      // Búsqueda por LIKE optimizada\n      const likeConditions = step.search_terms.map(term => \n        `(title LIKE '%${term}%' OR content LIKE '%${term}%')`\n      ).join(' AND ');\n      whereConditions.push(`(${likeConditions})`);\n    }\n  }\n  \n  // Agregar filtros adicionales\n  if (step.filters && Object.keys(step.filters).length > 0) {\n    const filterConditions = Object.entries(step.filters).map(([key, value]) => {\n      if (Array.isArray(value)) {\n        return `${key} IN (${value.map(v => `'${v}'`).join(', ')})`;\n      } else {\n        return `${key} = '${value}'`;\n      }\n    }).join(' AND ');\n    whereConditions.push(filterConditions);\n  }\n  \n  // Construir ORDER BY optimizado\n  if (step.sort_criteria && step.sort_criteria.length > 0) {\n    orderByClause = ' ORDER BY ' + step.sort_criteria.map(sort => \n      `${sort.field} ${sort.direction || 'ASC'}`\n    ).join(', ');\n  }\n  \n  // Agregar LIMIT\n  if (step.limit) {\n    limitClause = ` LIMIT ${step.limit}`;\n  }\n  \n  // Construir query final\n  const finalQuery = baseQuery + \n    (whereConditions.length > 0 ? ' WHERE ' + whereConditions.join(' AND ') : '') +\n    orderByClause +\n    limitClause;\n  \n  optimizedQueries.push({\n    step_number: 1,\n    query_type: 'optimized_search',\n    query: finalQuery,\n    estimated_results: step.limit || 100,\n    estimated_execution_time: '0.5 segundos',\n    performance_hints: [\n      performanceConfig.use_full_text_index ? 'USE FULLTEXT INDEX' : 'USE INDEX ON WHERE conditions',\n      'LIMIT results for better performance'\n    ]\n  });\n  \n} else if (strategy.operation_type === 'paginated_query') {\n  // Optimización para consultas paginadas\n  const step = executionPlan[0];\n  \n  let baseQuery = `SELECT * FROM ${strategy.operation_data?.table || 'paginated_table'}`;\n  let whereConditions = [];\n  \n  // Usar cursor pagination (más eficiente que OFFSET)\n  if (step.cursor_value && performanceConfig.use_cursor_pagination) {\n    const cursorCondition = step.sort_direction === 'DESC' ? \n      `${step.cursor_field} < '${step.cursor_value}'` :\n      `${step.cursor_field} > '${step.cursor_value}'`;\n    whereConditions.push(cursorCondition);\n  }\n  \n  // Agregar filtros adicionales\n  if (strategy.operation_data?.filters) {\n    const filterConditions = Object.entries(strategy.operation_data.filters).map(([key, value]) => \n      `${key} = '${value}'`\n    ).join(' AND ');\n    whereConditions.push(filterConditions);\n  }\n  \n  const orderByClause = ` ORDER BY ${step.cursor_field} ${step.sort_direction}`;\n  const limitClause = ` LIMIT ${step.page_size}`;\n  \n  const finalQuery = baseQuery +\n    (whereConditions.length > 0 ? ' WHERE ' + whereConditions.join(' AND ') : '') +\n    orderByClause +\n    limitClause;\n  \n  optimizedQueries.push({\n    step_number: 1,\n    query_type: 'cursor_paginated_query',\n    query: finalQuery,\n    estimated_results: step.page_size,\n    estimated_execution_time: '0.2 segundos',\n    performance_hints: [\n      'USE INDEX ON cursor field',\n      'Cursor pagination avoids OFFSET performance issues'\n    ]\n  });\n  \n  // Query opcional para contar total (si se requiere)\n  if (performanceConfig.enable_total_count) {\n    const countQuery = `SELECT COUNT(*) as total_count FROM ${strategy.operation_data?.table || 'paginated_table'}`;\n    optimizedQueries.push({\n      step_number: 2,\n      query_type: 'optimized_count_query',\n      query: countQuery,\n      estimated_results: 1,\n      estimated_execution_time: '0.1 segundos',\n      performance_hints: ['COUNT query with optimized indexes']\n    });\n  }\n  \n} else if (strategy.operation_type === 'analytics_query') {\n  // Optimización para consultas analíticas\n  const step = executionPlan[0];\n  \n  let selectClause = 'SELECT ';\n  let fromClause = `FROM ${strategy.operation_data?.table || 'analytics_table'}`;\n  let whereClause = '';\n  let groupByClause = '';\n  let orderByClause = '';\n  \n  // Construir agregaciones optimizadas\n  if (step.aggregations && step.aggregations.length > 0) {\n    const aggregationColumns = step.aggregations.map(agg => {\n      switch (agg.function) {\n        case 'count':\n          return `COUNT(${agg.column || '*'}) as ${agg.alias || 'count_result'}`;\n        case 'sum':\n          return `SUM(${agg.column}) as ${agg.alias || 'sum_result'}`;\n        case 'avg':\n          return `AVG(${agg.column}) as ${agg.alias || 'avg_result'}`;\n        case 'max':\n          return `MAX(${agg.column}) as ${agg.alias || 'max_result'}`;\n        case 'min':\n          return `MIN(${agg.column}) as ${agg.alias || 'min_result'}`;\n        default:\n          return `${agg.function}(${agg.column}) as ${agg.alias || 'result'}`;\n      }\n    }).join(', ');\n    \n    selectClause += aggregationColumns;\n  } else {\n    selectClause += '*';\n  }\n  \n  // Agregar campos de agrupación\n  if (step.grouping_fields && step.grouping_fields.length > 0) {\n    const groupingColumns = step.grouping_fields.join(', ');\n    selectClause += ', ' + groupingColumns;\n    groupByClause = ' GROUP BY ' + groupingColumns;\n  }\n  \n  // Filtros de rango temporal\n  if (step.time_range && (step.time_range.start || step.time_range.end)) {\n    const timeConditions = [];\n    if (step.time_range.start) {\n      timeConditions.push(`${step.time_range.field || 'created_at'} >= '${step.time_range.start}'`);\n    }\n    if (step.time_range.end) {\n      timeConditions.push(`${step.time_range.field || 'created_at'} <= '${step.time_range.end}'`);\n    }\n    whereClause = ' WHERE ' + timeConditions.join(' AND ');\n  }\n  \n  const finalQuery = selectClause + ' ' + fromClause + whereClause + groupByClause + orderByClause;\n  \n  optimizedQueries.push({\n    step_number: 1,\n    query_type: 'analytics_aggregation',\n    query: finalQuery,\n    estimated_results: step.grouping_fields?.length || 1,\n    estimated_execution_time: '1-5 segundos',\n    performance_hints: [\n      'USE INDEX ON grouping and time fields',\n      'Consider materialized views for frequently used analytics',\n      'Enable parallel aggregation for large datasets'\n    ]\n  });\n}\n\n// Generar plan de ejecución para consultas\nconst queryExecutionPlan = {\n  operation_id: strategy.operation_id,\n  optimization_summary: {\n    total_queries: optimizedQueries.length,\n    estimated_total_time: optimizedQueries.reduce((sum, q) => {\n      const timeStr = q.estimated_execution_time.split('-')[0]; // Tomar el valor mínimo\n      const seconds = parseFloat(timeStr.replace(' segundos', ''));\n      return sum + seconds;\n    }, 0) + ' segundos',\n    query_types: optimizedQueries.map(q => q.query_type),\n    performance_optimizations: strategy.optimization_applied\n  },\n  \n  execution_sequence: optimizedQueries,\n  \n  performance_configuration: {\n    enable_query_cache: performanceConfig.enable_query_cache || true,\n    use_read_replica: true,\n    connection_pooling: true,\n    result_compression: optimizedQueries.some(q => q.estimated_results > 1000)\n  },\n  \n  caching_strategy: strategy.operation_type === 'cache_query' ? {\n    cache_key: executionPlan[0]?.cache_key,\n    ttl: performanceConfig.cache_ttl,\n    cache_warming: performanceConfig.enable_cache_warming\n  } : null\n};\n\nconsole.log('Plan de consultas optimizado generado:', {\n  operationId: strategy.operation_id,\n  totalQueries: queryExecutionPlan.optimization_summary.total_queries,\n  estimatedTime: queryExecutionPlan.optimization_summary.estimated_total_time,\n  queryTypes: queryExecutionPlan.optimization_summary.query_types,\n  useCache: queryExecutionPlan.performance_configuration.enable_query_cache\n});\n\nreturn [{ json: queryExecutionPlan }];"
      },
      "id": "execute-query-operations",
      "name": "Ejecutar Operaciones Consulta",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 400]
    },
    {
      "parameters": {
        "functionCode": "// Función enfocada en generar respuesta final de optimización\n// Principio SRP: Una sola responsabilidad - consolidar resultados de optimización\n\nconst bulkExecution = $('Ejecutar Operaciones Masivas')?.first()?.json;\nconst queryExecution = $('Ejecutar Operaciones Consulta')?.first()?.json;\nconst strategy = $('Analizar Optimización').first().json;\n\n// Determinar qué plan de ejecución se generó\nconst executionPlan = bulkExecution || queryExecution;\n\nif (!executionPlan) {\n  throw new Error('No se generó plan de ejecución');\n}\n\n// Consolidar resultados finales\nconst optimizationResult = {\n  // Estado de la optimización\n  optimization_status: 'completed',\n  \n  // Resumen de la optimización\n  optimization_summary: {\n    operation_id: executionPlan.operation_id,\n    operation_type: strategy.operation_type,\n    optimization_path: bulkExecution ? 'bulk_operations' : 'query_operations',\n    optimizations_applied: strategy.optimization_applied,\n    complexity_score: strategy.optimization_metadata.complexity_score,\n    generated_at: new Date().toISOString()\n  },\n  \n  // Plan de ejecución optimizado\n  execution_plan: {\n    total_operations: executionPlan.optimization_summary.total_queries || executionPlan.execution_sequence?.length || 0,\n    estimated_execution_time: executionPlan.optimization_summary.estimated_total_time,\n    performance_configuration: executionPlan.performance_configuration,\n    execution_sequence: executionPlan.execution_sequence\n  },\n  \n  // Métricas de performance esperadas\n  performance_metrics: {\n    estimated_performance_gain: strategy.optimization_metadata.estimated_performance_gain,\n    optimized_queries_count: executionPlan.execution_sequence?.length || 0,\n    total_records_affected: executionPlan.optimization_summary?.total_records_affected || \n                           executionPlan.execution_sequence?.reduce((sum, q) => sum + (q.estimated_results || 0), 0) || 0,\n    \n    // Métricas específicas por tipo\n    bulk_metrics: bulkExecution ? {\n      use_transaction: executionPlan.performance_configuration.use_transaction,\n      parallel_processing: executionPlan.performance_configuration.parallel_processing,\n      batch_size: executionPlan.performance_configuration.batch_size,\n      rollback_strategy: executionPlan.rollback_strategy\n    } : null,\n    \n    query_metrics: queryExecution ? {\n      enable_query_cache: executionPlan.performance_configuration.enable_query_cache,\n      use_read_replica: executionPlan.performance_configuration.use_read_replica,\n      result_compression: executionPlan.performance_configuration.result_compression,\n      caching_strategy: executionPlan.caching_strategy\n    } : null\n  },\n  \n  // Recomendaciones para ejecución\n  execution_recommendations: {\n    // Recomendaciones generales\n    ready_for_execution: true,\n    recommended_execution_time: 'off_peak_hours',\n    monitoring_required: executionPlan.monitoring_config ? true : false,\n    \n    // Preparación previa\n    pre_execution_steps: [\n      bulkExecution && executionPlan.rollback_strategy?.backup_before_execution ? 'Create database backup' : null,\n      'Verify database connection pool',\n      'Check available system resources',\n      'Set appropriate transaction isolation level'\n    ].filter(Boolean),\n    \n    // Monitoreo durante ejecución\n    monitoring_points: [\n      'Query execution time',\n      'Database lock waits',\n      'Memory usage',\n      bulkExecution ? 'Transaction log growth' : 'Query cache hit ratio'\n    ],\n    \n    // Acciones post-ejecución\n    post_execution_steps: [\n      'Verify data integrity',\n      'Update statistics if needed',\n      bulkExecution ? 'Re-enable foreign key checks' : 'Clear query cache if needed',\n      'Log performance metrics'\n    ]\n  },\n  \n  // Información de trazabilidad\n  traceability: {\n    optimization_id: strategy.operation_id,\n    requesting_workflow: strategy.optimization_metadata.requesting_workflow,\n    tenant_context: strategy.optimization_metadata.tenant_context,\n    optimization_applied_at: strategy.optimization_metadata.requested_at,\n    optimization_coordinator: 'database-optimizer'\n  }\n};\n\n// Calcular score de optimización basado en mejoras aplicadas\nconst optimizationScore = Math.min(100, \n  (strategy.optimization_applied.length * 15) + \n  (executionPlan.execution_sequence?.length || 0) * 5 +\n  (strategy.optimization_metadata.complexity_score * 2)\n);\n\noptimizationResult.optimization_summary.optimization_score = optimizationScore;\n\n// Log final de optimización\nconsole.log('Optimización de base de datos completada:', {\n  operationId: optimizationResult.optimization_summary.operation_id,\n  operationType: optimizationResult.optimization_summary.operation_type,\n  optimizationPath: optimizationResult.optimization_summary.optimization_path,\n  optimizationScore: optimizationScore,\n  totalOperations: optimizationResult.execution_plan.total_operations,\n  estimatedTime: optimizationResult.execution_plan.estimated_execution_time,\n  readyForExecution: optimizationResult.execution_recommendations.ready_for_execution\n});\n\nreturn [{ json: optimizationResult }];"
      },
      "id": "consolidate-optimization-results",
      "name": "Consolidar Resultados Optimización",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 300]
    }
  ],
  "connections": {
    "Trigger del Workflow": {
      "main": [
        [
          {
            "node": "Analizar Optimización",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analizar Optimización": {
      "main": [
        [
          {
            "node": "¿Operación Masiva?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¿Operación Masiva?": {
      "main": [
        [
          {
            "node": "Ejecutar Operaciones Masivas",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ejecutar Operaciones Consulta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ejecutar Operaciones Masivas": {
      "main": [
        [
          {
            "node": "Consolidar Resultados Optimización",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ejecutar Operaciones Consulta": {
      "main": [
        [
          {
            "node": "Consolidar Resultados Optimización",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  }
}